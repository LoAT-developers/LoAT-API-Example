#include <cstdio>

#pragma push_macro("EOF")
#undef EOF
#include <antlr4-runtime.h>
#include "CINTLexer.h"
#include "CINTParser.h"
#pragma pop_macro("EOF")

#include "TranslatorVisitor.hpp"

#include <iostream>
#include <fstream>
#include <string>
#include <vector>

#include "loatsolver.hpp"
#include "loatlocation.hpp"
#include "loattransition.hpp"
#include "loatresult.hpp"                  

using namespace antlr4;

int main(int argc, const char* argv[]) {
    // 1) Determine input file and mode
    std::string inputFile = (argc >= 2 ? argv[1] : "../examples/safe.cint");
    std::ifstream stream(inputFile);
    if (!stream.good()) {
        std::cerr << "Error: Could not open input file: " << inputFile << std::endl;
        return 1;
    }

    bool safetyMode = true;
    if (argc >= 3) {
        std::string mode = argv[2];
        if (mode == "-safety") {
            safetyMode = true;
        }
        else if (mode == "-unsafety") {
            safetyMode = false;
        }
        else {
            std::cerr << "Invalid mode: '" << mode << "'. Please use '-safety' or '-unsafety'." << std::endl;
            return 1;
        }
    }


    // 2) ANTLR4 setup: CharStream, Lexer, TokenStream, Parser
    ANTLRInputStream input(stream);
    CINTLexer lexer(&input);
    CommonTokenStream tokens(&lexer);
    CINTParser parser(&tokens);

    parser.getInterpreter<atn::ParserATNSimulator>()
          ->setPredictionMode(atn::PredictionMode::SLL);

    // 3) Parse with start rule "main"
    tree::ParseTree* tree = parser.main();

    // 4) Invoke TranslatorVisitor
    TranslatorVisitor visitor;
    visitor.visit(tree);

    // 5) Retrieve all generated LoatTransition objects
    std::vector<LoatTransition> rawTransitions = visitor.getTransitions();
    if (rawTransitions.empty()) {
        std::cerr << "Warning: No transitions generated by TranslatorVisitor." << std::endl;
    }

    // 6) We will collapse all "sink_<n>" targets into exactly one sink: "sink"
    LoatLocation unifiedSink("sink");
    std::vector<LoatTransition> transitions;
    transitions.reserve(rawTransitions.size());

    for (auto& t : rawTransitions) {
        LoatLocation src  = t.getSourceLocation();
        LoatLocation tgt  = t.getTargetLocation();
        LoatBoolExprPtr g = t.getFormula();

        // If the transition's target name begins with "sink_", redirect it to "sink"
        std::string tgtName = tgt.getName();
        if (tgtName.rfind("sink_", 0) == 0) {
            transitions.emplace_back(src, unifiedSink, g);
        } else {
            transitions.emplace_back(src, tgt, g);
        }
    }

    // 7) Determine the unique start location (always "L0")
    LoatLocation startLoc("L0");

    // 8) Prepare a single sink list containing exactly "sink"
    std::vector<LoatLocation> sinkLocations = { unifiedSink };

    // Safety‚ÄêSolver configuration ======
    if(safetyMode) {
        LoatSolver safetySolver = LoatSolver::forSafety();
        safetySolver.setParameter(DynamicParameterKey::Log, true);
        safetySolver.setStartLocation(startLoc);
        safetySolver.addSinkLocation(unifiedSink);
        for (auto& t : transitions) {
            safetySolver.add(t);
        }
        LoatResult safetyResult = safetySolver.check();

        std::cout << "======== Safety Check ========" << std::endl;
        if (safetyResult == LoatResult::SAT) {
            std::cout << "Program is SAFE (no path reaches the single sink under safety semantics)." << std::endl;
        } else {
            std::cout << "Program UNDECIDED/UNSAFE" << std::endl;
        }
        std::cout << std::endl;
    } else {
        LoatSolver unsafetySolver = LoatSolver::forUnsafety();
        unsafetySolver.setStartLocation(startLoc);
        unsafetySolver.addSinkLocation(unifiedSink);
        for (auto& t : transitions) {
            unsafetySolver.add(t);
        }
        LoatResult unsafetyResult = unsafetySolver.check();

        std::cout << "======== Unsafety Check ========\n";
        if (unsafetyResult == LoatResult::UNSAT) {
            std::cout << "Program is UNSAFE (found a violating path to the single sink under unsafety semantics):" << std::endl;
        } else {
            std::cout << "Program is NON UNSAFE (no violating path to the single sink under unsafety semantics)." << std::endl;
        }
        std::cout << std::endl;
    }
    

    return 0;
}
