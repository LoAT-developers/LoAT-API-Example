#include <cstdio>

#pragma push_macro("EOF")
#undef EOF
#include <antlr4-runtime.h>
#include "CINTLexer.h"
#include "CINTParser.h"
#pragma pop_macro("EOF")

#include "TranslatorVisitor.hpp"

#include <iostream>
#include <fstream>
#include <string>
#include <vector>

#include "loatsolver.hpp"
#include "loatlocation.hpp"
#include "loattransition.hpp"
#include "loatresult.hpp"

using namespace antlr4;

int main(int argc, const char *argv[])
{
    // 1) Determine input file and mode
    std::string inputFile = (argc >= 2 ? argv[1] : "../examples/safe.cint");
    std::ifstream stream(inputFile);
    if (!stream.good())
    {
        std::cerr << "Error: Could not open input file: " << inputFile << std::endl;
        return 1;
    }

    bool safetyMode = true;
    if (argc >= 3)
    {
        std::string mode = argv[2];
        if (mode == "-safety")
        {
            safetyMode = true;
        }
        else if (mode == "-unsafety")
        {
            safetyMode = false;
        }
        else
        {
            std::cerr << "Invalid mode: '" << mode << "'. Please use '-safety' or '-unsafety'." << std::endl;
            return 1;
        }
    }

    // 2) ANTLR4 setup: CharStream, Lexer, TokenStream, Parser
    ANTLRInputStream input(stream);
    CINTLexer lexer(&input);
    CommonTokenStream tokens(&lexer);
    CINTParser parser(&tokens);

    parser.getInterpreter<atn::ParserATNSimulator>()
        ->setPredictionMode(atn::PredictionMode::SLL);

    // 3) Parse with start rule "main"
    tree::ParseTree *tree = parser.main();

    // 4) Invoke TranslatorVisitor
    TranslatorVisitor visitor;
    visitor.visit(tree);

    // 5) Retrieve all generated LoatTransition objects
    std::vector<LoatTransition> rawTransitions = visitor.getTransitions();
    if (rawTransitions.empty())
    {
        std::cerr << "Warning: No transitions generated by TranslatorVisitor." << std::endl;
    }

    // 7) Determine the unique start location (always "L0")
    LoatLocation startLoc("L0");

    // 8) Prepare a single sink list containing exactly "sink"

    // Safety‐Solver configuration ======
    if (safetyMode)
    {
        LoatSolver safetySolver = LoatSolver::forSafety();
        safetySolver.setParameter(DynamicParameterKey::Log, true);
        safetySolver.setParameter(DynamicParameterKey::PrintDependencyGraph, true);
        safetySolver.setStartLocation(startLoc);
        safetySolver.addSinkLocation(LoatLocation("sink"));
        for (auto &t : rawTransitions)
        {
            safetySolver.add(t);
        }
        LoatResult safetyResult = safetySolver.check();

        std::cout << "======== Safety Check ========" << std::endl;
        if (safetyResult == LoatResult::SAT)
        {
            std::cout << "Program is SAFE" << std::endl;
        }
        else
        {
            std::cout << "Program UNDECIDED/UNSAFE" << std::endl;
        }
        std::cout << std::endl;
    }
    else
    {
        LoatSolver unsafetySolver = LoatSolver::forUnsafety();
        unsafetySolver.setStartLocation(startLoc);
        unsafetySolver.addSinkLocation(LoatLocation("sink"));
        for (auto &t : rawTransitions)
        {
            unsafetySolver.add(t);
        }
        LoatResult unsafetyResult = unsafetySolver.check();

        std::cout << "======== Unsafety Check ========\n";
        if (unsafetyResult == LoatResult::UNSAT)
        {
            std::cout << "Program is UNSAFE" << std::endl;
        }
        else
        {
            std::cout << "Program is NON UNSAFE" << std::endl;
        }
        std::cout << std::endl;
    }

    return 0;
}
